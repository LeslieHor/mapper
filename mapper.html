<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Mapper</title>
        <style>
html, body {
    margin: 0;
    height: 100%;
}

body {
    margin-left: 422px; /* leave space for sidebar */
    height: 100vh;
    background: #dcdcdc;
    -webkit-user-select: none; /* Safari */
    -moz-user-select: none;    /* Firefox */
    -ms-user-select: none;
    user-select: none;
    overflow: auto;     /* enable scrolling */
}

#workspace {
    position: relative;
    padding-bottom: 20px;
}

.page {
    background: #ffffff;
    position: relative;
    margin-top: 20px;
    margin-left: 20px;
    width: 1122px;
    height: 794px;
    border: 2px dashed #999;
    z-index: 1;
}

/* ===== Sidebar ===== */

#sidebar {
    position: fixed;
    top: 0;
    left: 0;
    width: 422px;
    height: 100vh;
    background: #f0f0f0;
    border-right: 1px solid #ccc;
    padding: 10px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 1000;
}

/* #sidebar button {
    padding: 8px;
    cursor: pointer;
} */

#sidebar textarea {
    flex: 1;
    resize: none;
    width: 100%;
}

#sidebar-title {
    font-family: "Verdana";
    font-weight: bold;
    font-size: 1.2em;
    padding: 4px 6px;
    border-bottom: 1px solid #ccc;
    margin-bottom: 10px;
    outline: none; /* remove default focus outline */
}

#toolbar {
    display: grid;
    grid-template-columns: repeat(auto-fill, 40px); /* fixed width buttons, wrap to new row */
    grid-auto-rows: 40px;
    gap: 5px;
}

.tool-button {
    width: 40px;       /* smaller, icon-friendly */
    height: 40px;
    padding: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 6px;
    border: 1px solid #ccc;
    background: #f0f0f0;
    font-size: 28px;
}

.tool-button:hover {
    background-color: #0077ff45;
}

.tool-button.active {
    background-color: #0077ff;
    color: white;
}

#tool-save.unsaved {
    background-color: red;
}

/* ===== Notes ===== */

.note {
    position: absolute;
    min-width: 1ch;
    min-height: 1em;
    box-shadow: 2px 3px 6px rgba(0,0,0,.3);
    cursor: move;
    z-index: 10;
    padding: 10px;
}

.note[contenteditable]:focus {
    outline: none;
    cursor: text;
}

.note.editing {
    box-shadow: 0 0 20px #0000ff;
    -webkit-user-select: text;
    -moz-user-select: text;
    -ms-user-select: text;
    user-select: text;
}

/* ===== Post It Note ===== */

.postit {
    font-family: "Courier New";
    font-size: 16px;
    font-weight: 600;
    max-width: 30ch;
    max-height: 19em;
    background: #fff3a0;

    overflow-wrap: break-word;
    white-space: pre-wrap;
    word-break: break-word;
}
/* ===== Tape ===== */

.tape {
    font-family: "Brush Script MT";
    font-size: 75px;
    height: 90px;
    background: #f4f0d5;
}

/* ===== Tape ===== */

.paper {
    font-family: "Courier New";
    font-size: 16px;
    font-weight: 600;
    background: #ffffff;
    max-width: 501px;
    max-height: 1122px;

    overflow-wrap: break-word;
    white-space: pre-wrap;
    word-break: break-word;
}

/* ===== Lines and Arrows ===== */

.line, .arrow {
    position: absolute;
    height: 4px;
    background: blue;
    transform-origin: 0 50%;
    z-index: 5;
}

/* invisible click target */
.line::before, .arrow:before {
    content: "";
    position: absolute;
    top: -6px;
    left: 0;
    width: 100%;
    height: 14px;       /* click thickness */
    background: transparent;
}

.arrow::after {
    content: "";
    position: absolute;
    width: 0;
    height: 0;
    border-left: 20px solid blue;   /* arrow size and color */
    border-top: 10px solid transparent;
    border-bottom: 10px solid transparent;
    /*right: 0;  /* attach to end of line */
    left: 100%; /* move to end of line */
    top: 50%;
    transform: translateY(-50%) rotate(0deg);
}

.pass-through {
    pointer-events: none;
}

/* Show red border for things you are going to delete */
/* only show hover when Alt is down */
body.alt-down .line:hover {
    box-shadow: 0 0 0 6px rgba(255, 0, 0, 0.15); /* highlight hit area */
    cursor: pointer;
}
body.alt-down .arrow:hover {
    box-shadow: 0 0 0 6px rgba(255, 0, 0, 0.15); /* highlight hit area */
    cursor: pointer;
}

body.alt-down .postit:hover {
    box-shadow: 0 0 0 6px rgba(255, 0, 0, 0.15); /* highlight hit area */
    cursor: pointer;
}

body.alt-down .tape:hover {
    box-shadow: 0 0 0 6px rgba(255, 0, 0, 0.15); /* highlight hit area */
    cursor: pointer;
}

body.alt-down .paper:hover {
    box-shadow: 0 0 0 6px rgba(255, 0, 0, 0.15); /* highlight hit area */
    cursor: pointer;
}


.diagram-list-title {
    font-family: "Verdana";
    font-size: 12px;
}

#diagram-list {
    overflow-y: auto;
    max-height: 500px;
    border: 1px solid #ccc;
    padding: 4px;
}

.diagram-item {
    font-family: "Verdana";
    font-size: 14px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 2px 4px;
    cursor: pointer;
}

.diagram-item:hover {
    background-color: rgb(127, 185, 255);
}

.diagram-delete-button {
    margin-left: 4px;
    font-size: 0.8em;
}

.build-number {
    font-family: "Verdana";
    font-size: 8px;
}

.help-text {
    display: flex;
    flex-wrap: wrap;       /* allow wrapping if they run out of space */
    gap: 6px;              /* space between tags */
    align-items: center;
}

.help-element {
    font-family: "Verdana";
    display: inline-block;
    background-color: #e0e0e0;
    color: #333;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;   /* keep the text on one line */
}

.diagram-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 4px 6px;
    cursor: pointer;
}

.diagram-controls {
    display: flex;
    gap: 4px;
}

.diagram-controls button {
    padding: 2px 6px;
    font-size: 12px;
    line-height: 1;
}
        </style>
    </head>
    <body>
        <div id="sidebar">
            <div id="sidebar-title" contenteditable="true" spellcheck="false">New Diagram</div>

            <div id="toolbar">
                <button id="tool-page" class="tool-button"><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAdElEQVRYR+2WCQ4AEAwE+f+jCQmRuNKiJdYD7BgttUZ5WeV8A4CrDDjheoiHLw0EACkjOet5gHRtVHPbDAAABv4wsPpCtlqU1IbqAKMv4o8agAEYuNoAd4ojPUTckJm55kx4Iqy3ZwUgGZ6zqLPcdkgAqBvwQDs6IcqJ/98AAAAASUVORK5CYIIA"></button>
                <button id="tool-tape" class="tool-button"><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAu0lEQVRYR+2X3QrAIAiF1/s/9IYwQcL0SLpguNv8+TzKsnEd/sbh/BcCcL+QiK2sB/JDgnIgCo7Ykx3sgwSkYGQHVTTZse+y0xEAWdnKb4ZMB7AgNIVKADSIVXvKAOZBWw1oKQA6E+acRYcw+t8qV8ADaoBWoBVoBf6vgLeklCog167Pb0Nt89EgShSwlo8ZIh0A6bmESAXwkvPVLO3SADg4ssCUvAsijxJNia13gbf1bJ2jkm4lsZyPAzxakEohrB/z5gAAAABJRU5ErkJgggAA"></button>
                <button id="tool-note" class="tool-button"><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAfElEQVRYR+2WOwoAIAxD9f6HVhzc7CfS0CXOSp5PpJmjec3m/CEAy8AiPM0zywOofJ5zIQHIgAzIgAzIANVAZnrSAaLR3gJwzZijvaoPvOZ9GH5KDwsgFc4CSIczAKDwaoDbY6EuGX0dtBxD4Z4BNPh7P0z8nWQcFEC7gQ0O9jIhF8LMeQAAAABJRU5ErkJgggAA"></button>
                <button id="tool-paper" class="tool-button"><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAZklEQVRYR+2XMQoAIAwD7f8frXRwtIIpHELcNdfEDI0Bn4D1RwUwG+GOOjeADodykL8BlChy8v8dUP+i7IAjcAS4AziAW+AIcAdwALfAEeAO4ABuARqBKr7vP21GXeLlOx27nwS6AFtSPiFiXfQSAAAAAElFTkSuQmCC"></button>
                <button id="tool-line" class="tool-button"><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAmUlEQVRYR8XXWQ6AIBRDUdj/ojUmSqIyvKEtbOCel/DTWja/urlf1IDjPrh1lYAnfhnkgG78JSH+hWFcAZjG2YBlnAkwxVkAc5wBcMXRAHccCQjFUYBwHAFIxbOAdDwDgMSjAFg8AoDGvQB43AOgxK0AWtwCoMZXAHp8BpDERwBZvAeQxr8AeXwEUI4V+TT7zQ/ptb3xsx1wAhkyGyFCb2MYAAAAAElFTkSuQmCC"></button>
                <button id="tool-arrow" class="tool-button"><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAqklEQVRYR+3XQQ6AIAxEUbj/oSVdYAgWKKUzbHRnovlPgjXmdPnIl/vpFPA4H+DtngKk70GEAiyL0COpAG2FaIA2LtF6TgH08Xa/wAFanAYYxSmAWRwOWMWhAEscBrDGIYCdeJ2Yck/Ia+iJf8a292MUEheNBxAW9wBC47uA8PgOABK3AmBxCwAaXwHg8RmAEh8BaHENQI33AHp8BPCMZ8u/gXoNNaYJfkABSCokIZlOTPgAAAAASUVORK5CYIIA"></button>
                <button id="tool-image" class="tool-button"><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA5klEQVRYR+2XURKAIAhE6/6HrnEmGmIgYMH8qU9T9rmQ0r4tfvbF+psEOD4CunU1gNmujE26ALOcGMJhgG4nSLgNQLrkAbcCPHZxFa42xmu6DeBNKPIOTgFZ/ma1ukvhEATg2UtWc0i5ppyCKISW9zFWAkDEuWgJABHX6gV2AAWwjvl0EVrFZFnMC5JDwA5o+ZPB+KlIotO/AinKociFNgesNoHv0quVUgp+gN8BzYFsT9BWhN61rJ0JpbvAut0iHbz2mYaP4ohAdk64K84Gzsx3HcgEQ+eaPyZoQHid18vDgaMLlwOc2JuSIYJ1qq0AAAAASUVORK5CYIIA"></button>
                <button id="tool-undo" class="tool-button"><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAx0lEQVRYR+2XSw6AIAxE8f6H1pBIQiKfN7VNN7jVdh5TKPUqyc+VrF8sAPcLbYn9rFdN0sRrIjV2aLaSxF1cWUWIOAUIEycAvfjswChllDchAWhJTSAkaFeC3ftlqyEANQERId/IJegDiIDcpKgDDcQdQgXoy7GKxU5YAMj9lQ5AnfK5UCaWIBeiSnAcOA6kO4BOAJkHSNMZfZMKgMUjHJDEvQHITflrHpjtB5OwOseR2dDU1mnQCoDm+P1nZD2SLkNpiHhN+gBL0iEhdrXZGgAAAABJRU5ErkJgggAA"></button>
                <button id="tool-redo" class="tool-button"><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAwUlEQVRYR+2W0Q6AIAhF8/8/uuaWzdaMcxHmi73GuMeLgOVY/JXF+kckwHkfRsopBRtuNYAahvPiQFgqGSIaoHJKEBkAEkQEQH/iUaWGOjMARLgBhQNYdbb+P06pDpDEJGYaYAQuiUsDo2uvMHEFgIxZEvPpEnoHXMnJ9CQAaeK0BBtgO7Ad6Pc7aVvS/vIuSCuDcqIUCAUgpRReADpFzfugArSE8t6XH4sm+vv57c7vdaAX/HucmvnNAODEVMhygAuT4SEhhcz4/QAAAABJRU5ErkJgggAA"></button>
                <button id="tool-save" class="tool-button"><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAtUlEQVRYR+2W0Q6AIAhF9f8/uuYDmxHKlRBb2VNrIMcL3sxp8ZMX10+vBDgcVVE3KAUUAPpevyNcPLfkdCFmApTipGYTYjaAChEB0IWIAmhCaAB1IjKE2tTfhhoBQAqjMd8C4IalyU/tvMRZWyAZFGJabi3YAMsVkPwhdAjRc8/j3IYwHMB6SeFtMSmAnO+WIjx3GOBJcYLq3rA0J9wA/1XAes6RPPV3jCziFoP4t1sxaaENcALHlFIhSlGXbwAAAABJRU5ErkJgggAA"></button>
                <button id="export" class="tool-button"><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAk0lEQVRYR+2WUQrAIAxD9f6HnhMmuNKyxH7oIPtuk9dYh7Vs/upm/yKA3ydwPTu0PMhq4zC2O0zr0Q23Y2Q+YChNqtiY9975CGYwWBcudMz7xHYHaAgUIBL2lpCCYAFsfXQL4NuBAkR/bNgoEhCAElACSkAJZBNIP6o9gK8HR9b05XkkQHZCqv/IHaAmyBYrge0JNK+cHCELSkDeAAAAAElFTkSuQmCC"></button>
                <button id="import" class="tool-button"><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAl0lEQVRYR+2W4QqAMAiEt/d/6GKwQOwWngUW3X4O9T4P2eyt+PRi/SaAzzuwzRlKN5JOnMICkANyQA78x4FVp+z96fePPsWH0ChgcxDAKhauHlGAkYwKewBK3HcTWY68gAWgxTMA3gkEzbiaXslstxaCEs86YAXL34HI3FzGIMtW9t4WQ+vbKwGe6jRUh57aUFUiSAByYAdtvBwh4SVw3wAAAABJRU5ErkJgggAA"></button>
                <button id="debug" class="tool-button"><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABJklEQVRYR82W4Q7CMAiE7fs/tG6JbbA74KM1Tn8tDrjrcbC2x82/toD/PHJW8iTUSqFbCFhQ8oyFpQoQ0FkZpJRHgBYjxEI1KAEs6RGoyJ/5Emv+0zvRTOCMU7+oXjlB9bADR8p5p7WkR74q5JkHmep9zFlJ3AKv1xXwXgPlkDFEhRzmqRK/JGCV6c/NElAGq/ihEjsE80zYTbMjP/JC1oKMQPb+JBH6QLXAjgwByLZkuE9WFIhIeWAuzl8R8NYsPRWJu8SQVRz10Paf1JpNie92K2ZEeyHzgD1hhUQWO96r7/dYk2K+dj7H6D6QzbTa55kPLn0nCZRIJU62JfKAvMFUEKdYRCAD/fquoFMQma+6mj+EoQRWr2rZOOJFtNH6OHVXgW1iL5UeYyGvimoAAAAAAElFTkSuQmCC"></button>
            </div>
            <div id="diagram-list-container">
                <span class="diagram-list-title">Diagrams</span>
                <div id="diagram-list"></div>
            </div>
            <button id="new-diagram">New</button>
            <textarea id="data"></textarea>
            <div class="help-text">
                <span class="help-element">1: Tape</span>
                <span class="help-element">2: Post it</span>
                <span class="help-element">3: Paper</span>
                <span class="help-element">Ctrl+s: Save</span>
                <span class="help-element">Ctrl+u: Underline</span>
                <span class="help-element">Ctrl+h: Highlight</span>
            </div>
            <div class="build-number">202601141909</div>
        </div>

        <div id="workspace">
        </div>
<input type="file" id="import-file" accept="application/json" style="display:none"/>
    </body>
    <script>
let state = {
    version: 1,
    title: "",
    pages: 1,
    notes: [],
    lines: [],
    arrows: []
};

// State for dragging items
let dragTarget = null;
let dragStartX = 0;
let dragStartY = 0;
let noteStartX = 0;
let noteStartY = 0;

// Tracks if a note (and which note) is being edited
let editingNote = null;

let activeTool = null;

// Tracks origin when drawing a line
let drawingLine = null;
let startX = 0;
let startY = 0;

function clearEditingNote() {
    if (editingNote) {
        editingNote.contentEditable = false;
        editingNote.classList.remove("editing");
        editingNote = null;

        // Clear text selection
        const sel = window.getSelection();
        sel.removeAllRanges();

        updateState();
        return
    }
}

function makePage() {
    const el = document.createElement("div");
    el.className = "page";
    workspace.appendChild(el);
}

// Clicking adds something based on the tool
workspace.addEventListener("mousedown", e => {
    clearEditingNote();

    const x = e.pageX;
    const y = e.pageY;

    if (activeTool == "line") {
        startX = x;
        startY = y;
        const el = createLine(x, y, x, y);
        drawingLine = el;
    } else if (activeTool == "arrow") {
        startX = x;
        startY = y;
        const el = createArrow(x, y, x, y);
        drawingLine = el;
        
    }
});

workspace.addEventListener("dblclick", e => {
    clearEditingNote();

    const x = e.pageX;
    const y = e.pageY;

    if (activeTool == "postit") {
        const el = createPostIt(x, y);
        makeEditable(el, true);
        updateState();
    } else if (activeTool == "tape") {
        const el = createTape(x, y);
        makeEditable(el, true);
        updateState();
    } else if (activeTool == "paper") {
        const el = createPaper(x, y);
        makeEditable(el, true);
        updateState();
    }
});

/* ===== Notes Logic ===== */

function makeNote(type, x, y, text) {
    const el = document.createElement("div");
    el.className = "note";
    el.classList.add(type);
    el.contentEditable = false;
    el.innerHTML = text;
    el.style.left = x + "px";
    el.style.top = y + "px";
    restrictToPlainText(el)

    // Double clicking makes the note editable
    el.addEventListener("dblclick", e => {
        // If double clicking the note that is being edited, don't change anything.
        if (editingNote == el) {
            return
        }
        // Clear any note that is currently being edited.
        clearEditingNote();
        // make the note editable
        makeEditable(el, false);
    });

    // Alt + Click will delete the note // Move this to mouse down
    el.addEventListener("click", e => {
        if (e.altKey) {
            el.remove();
            updateState();
        }
    });

    el.addEventListener("mousedown", e => {
        if (el.isContentEditable) {
            // Don't initiate dragging if we're editing
            // We are probably just selecting text
            return
        }
        const rect = el.getBoundingClientRect();
        dragTarget = el;
        dragStartX = e.pageX;
        dragStartY = e.pageY;
        noteStartX = rect.left + window.scrollX;
        noteStartY = rect.top + window.scrollY;

        if (!e.shiftKey) {
            el.parentElement.appendChild(el); // Bring this note to the foreground
        }
    });

    el.addEventListener("keydown", (e) => {
        if (!editingNote) return; // Only act if a note is being edited

        // Check for Ctrl/Cmd + U
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "u") {
            e.preventDefault(); // Prevent default browser behavior
            document.execCommand("underline");
        }

        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "h") {
            e.preventDefault(); // Prevent default browser behavior
            document.execCommand("hiliteColor", false, "orange");
        }
    });


    document.body.appendChild(el);
    return el;
}

function makeEditable(el, selectAll = false) {
    el.contentEditable = true;
    el.classList.add("editing");
    editingNote = el;

    if (selectAll) {
        const range = document.createRange();
        range.selectNodeContents(el);

        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
    }
    
    // defer focus slightly to let the browser finish rendering
    setTimeout(() => el.focus(), 0);
}

function restrictToPlainText(note) {
    note.addEventListener("paste", e => {
        e.preventDefault(); // stop the default rich text paste
        // Get plain text from clipboard
        const text = (e.clipboardData || window.clipboardData).getData("text/plain");
        // Insert it at the current cursor position
        insertTextAtCursor(note, text);
    });
}

function insertTextAtCursor(el, text) {
    const sel = window.getSelection();
    if (!sel.rangeCount) return;

    const range = sel.getRangeAt(0);
    range.deleteContents(); // remove selection if any

    const textNode = document.createTextNode(text);
    range.insertNode(textNode);

    // Move cursor after inserted text
    range.setStartAfter(textNode);
    range.setEndAfter(textNode);
    sel.removeAllRanges();
    sel.addRange(range);
}

// Added outside of the note so that you can drag faster.
// Even if the cursor moves outside the element, it will still drag.
document.addEventListener("mousemove", e => {
    if (dragTarget) {
        clearEditingNote();

        const dx = e.pageX - dragStartX;
        const dy = e.pageY - dragStartY;

        dragTarget.style.left = noteStartX + dx + "px";
        dragTarget.style.top  = noteStartY + dy + "px";
    }
});

document.addEventListener("mouseup", () => {
    if (dragTarget) {
        dragTarget = null;
        updateState();
    }
});

/* ===== Lines and Arrow Logic ===== */

function makeLine(type, x1, y1, x2, y2) {
    const line = document.createElement("div");
    line.className = type;
    setLineGeometry(line, x1, y1, x2, y2);
    line.classList.add("pass-through")

    // Alt + click deletes the line
    line.addEventListener("mousedown", e => {
        if (e.altKey) {
            line.remove();
            updateState();
        }
    });

    document.body.appendChild(line);
    return line;
}

// Save the x y coordinates for json export
function setLineGeometry(line, x1, y1, x2, y2) {
    line.dataset.x1 = x1;
    line.dataset.y1 = y1;
    line.dataset.x2 = x2;
    line.dataset.y2 = y2;
    updateLine(line, x1, y1, x2, y2);
}

function updateLine(line, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const length = Math.hypot(dx, dy);
    const angle = Math.atan2(dy, dx) * 180 / Math.PI;

    line.style.left = x1 + "px";
    line.style.top = y1 + "px";
    line.style.width = length + "px";
    line.style.transform = `rotate(${angle}deg)`;
}

// We are in the middle of drawing a line.
document.addEventListener("mousemove", e => {
    if (drawingLine) {
        setLineGeometry(drawingLine, startX, startY, e.pageX, e.pageY);
    }
});

const MIN_LINE_LENGTH = 10;

// Mouse release whilst creating a line
document.addEventListener("mouseup", () => {
    if (!drawingLine) return;

    const x1 = Number(drawingLine.dataset.x1);
    const y1 = Number(drawingLine.dataset.y1);
    const x2 = Number(drawingLine.dataset.x2);
    const y2 = Number(drawingLine.dataset.y2);

    const length = Math.hypot(x2 - x1, y2 - y1);

    if (length < MIN_LINE_LENGTH) {
        // Treat as mis-click
        drawingLine.remove();
    } else {
        updateState();
    }

    drawingLine = null;
});

/* ===== Creating notes ===== */

function createNote(type, x, y, text) {
    if (type == "postit") {
        createPostIt(x, y, text);
    } else if (type == "tape") {
        createTape(x, y, text);
    } else if (type == "paper") {
        createPaper(x, y, text)
    }
}

function createPostIt(x, y, text = "<div>Text</div>") {
    return makeNote("postit", x, y, text);
}

function createTape(x, y, text = "Text") {
    const el = makeNote("tape", x, y, text);
    el.addEventListener("keydown", e => {
        if (e.key === "Enter") {
            e.preventDefault();  // Stop newline insertion
        }
    });
    return el;
}

function createPaper(x, y, text = "<div>Text</div>") {
    return makeNote("paper", x, y, text);
}

function createLine(x1, y1, x2, y2) {
    return makeLine("line", x1, y1, x2, y2);
}

function createArrow(x1, y1, x2, y2) {
    return makeLine("arrow", x1, y1, x2, y2);
}

/* ===== Sidebar Buttons ===== */

const toolTapeButton = document.getElementById("tool-tape");
const toolNoteButton = document.getElementById("tool-note");
const toolPaperButton = document.getElementById("tool-paper");
const toolLineButton = document.getElementById("tool-line");
const toolArrowButton = document.getElementById("tool-arrow");

function resetTool() {
    toolTapeButton.classList.toggle("active", false);
    toolNoteButton.classList.toggle("active", false);
    toolPaperButton.classList.toggle("active", false);
    toolLineButton.classList.toggle("active", false);
    toolArrowButton.classList.toggle("active", false);
    activeTool = null;
}

function switchTool(button, tool) {
    if (activeTool == tool) {
        resetTool();
        return
    }
    resetTool();
    button.classList.toggle("active", true);
    activeTool = tool;
}

document.getElementById("sidebar-title").addEventListener("blur", (e) => {
    updateState();
});

document.getElementById("tool-page").addEventListener("click", (e) => {
    makePage();
    updateState();
});

document.getElementById("tool-note").addEventListener("click", (e) => {
    switchTool(e.currentTarget, "postit");
});

document.getElementById("tool-tape").addEventListener("click", (e) => {
    switchTool(e.currentTarget, "tape");
});

document.getElementById("tool-paper").addEventListener("click", (e) => {
    switchTool(e.currentTarget, "paper");
});

document.getElementById("tool-line").addEventListener("click", (e) => {
    switchTool(e.currentTarget, "line");
});

document.getElementById("tool-arrow").addEventListener("click", (e) => {
    switchTool(e.currentTarget, "arrow");
});

document.getElementById("tool-image").addEventListener("click", (e) => {
    addImage();
});

document.getElementById("tool-undo").addEventListener("click", (e) => {
    undo();
});

document.getElementById("tool-redo").addEventListener("click", (e) => {
    redo();
});

document.getElementById("tool-save").addEventListener("click", (e) => {
    saveDiagram();
    refreshDiagramList();
});

document.getElementById("new-diagram").addEventListener("click", (e) => {
    newDiagram();
});

document.getElementById("export").addEventListener("click", (e) => {
    downloadDiagrams();
});

document.getElementById("import").addEventListener("click", (e) => {
    importJson();
});

document.getElementById("debug").addEventListener("click", (e) => {
    // Special button used for very specific use cases to help deal with development issues
    alert("Nothing here");
});

// Keep track of whether the alt key is pressed down so we can use it for css.
document.addEventListener("keydown", e => {
    if (e.key === "Alt") {
        document.body.classList.add("alt-down");
        enableLineClicks();
    }
});

document.addEventListener("keyup", e => {
    if (e.key === "Alt") {
        document.body.classList.remove("alt-down");
        disableLineClicks();
    }
});

// Disable the alt state when the user moves away from the window
// Not sure which one I'm supposed to use to do this properly.
document.addEventListener("visibilitychange", () => {
    document.body.classList.remove("alt-down");
    disableLineClicks();
});

window.addEventListener("blur", () => {
    document.body.classList.remove("alt-down");
    disableLineClicks();
});


// Pressing escape should stop any edits
document.addEventListener("keydown", e => {
    if (e.key === "Escape") {
        clearEditingNote();
    }
});

document.addEventListener("keydown", e => {
    // Check for Ctrl+S (Windows/Linux) or Cmd+S (Mac)
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s") {
        e.preventDefault(); // prevent browser save dialog
        saveDiagram();
        refreshDiagramList();
    }
});


/* ===== Enabling / Disabling clicks on lines ===== */
/* Disable clicks to make it easier to draw joined arrows, but allow clicks when trying to delete */

function enableLineClicks() {
    document.querySelectorAll(".line,.arrow").forEach(e =>
        e.classList.remove("pass-through")
    );
}

function disableLineClicks() {
    document.querySelectorAll(".line,.arrow").forEach(e =>
        e.classList.add("pass-through")
    );
}

/* ===== Saving / Loading ===== */

let history = [];
let historyIndex = -1;
const maxHistory = 50;

function clearHistory() {
    history = []
    historyIndex = -1;
    pushHistory();
}

function pushHistory() {
    // trim forward history if we undid some steps
    history = history.slice(0, historyIndex + 1);

    // save a deep copy of current state
    history.push(JSON.parse(JSON.stringify(state)));
    if (history.length > maxHistory) history.shift();
    historyIndex = history.length - 1;
}

function undo() {
    if (historyIndex > 0) {
        historyIndex--;
        loadState(history[historyIndex]);
    }
}

function redo() {
    if (historyIndex < history.length - 1) {
        historyIndex++;
        loadState(history[historyIndex]);
    }
}

function stripHTMLNewlines(s) {
    return s.replace(/<div>/g, "")
            .replace(/<\/div>$/, "")
            .replace(/<\/div>/g, "\n")
            .replace(/<br>/g, "")
}

function restoreHTMLNewLines(s){
    return s.replace(/^/g, "<div>")
            .replace(/\n/g, "</div><div>")
            .replace(/$/, "</div>")
            .replace(/<div><\/div>/g, "<div><br></div>");
}

function getNoteHTMLType(el) {
    if (el.classList.contains("postit")) {
        return "postit"
    } else if (el.classList.contains("tape")) {
        return "tape"
    } else if (el.classList.contains("paper")) {
        return "paper"
    }
}

function getNoteDataType(e) {
    if (e.type == "postit") {
        return "postit"
    } else if (e.type == "tape") {
        return "tape"
    } else if (e.type == "paper") {
        return "paper"
    }
}

function getStrippedText(el) {
    if (getNoteHTMLType(el) == "tape") {
        return el.innerText;
    }
    return stripHTMLNewlines(el.innerHTML);
}

function getRestoredText(e) {
    if (getNoteDataType(e) == "tape") {
        return e.text;
    }
    return restoreHTMLNewLines(e.text);
}

function updateState(showUnsaved = true) {
    state.title = document.getElementById("sidebar-title").innerText;
    state.pages = document.querySelectorAll(".page").length;
    state.notes = [...document.querySelectorAll(".note")].map(n => ({
        type: getNoteHTMLType(n),
        x: parseInt(n.style.left),
        y: parseInt(n.style.top),
        text: getStrippedText(n)
    }));
    state.lines = [...document.querySelectorAll(".line")].map(l => ({
        x1: Number(l.dataset.x1),
        y1: Number(l.dataset.y1),
        x2: Number(l.dataset.x2),
        y2: Number(l.dataset.y2)
    }));
    state.arrows = [...document.querySelectorAll(".arrow")].map(l => ({
        x1: Number(l.dataset.x1),
        y1: Number(l.dataset.y1),
        x2: Number(l.dataset.x2),
        y2: Number(l.dataset.y2)
    }));

    pushHistory();
    // As a debug feature, spit out the json into a data viewer
    document.getElementById("data").value = JSON.stringify(state, null, 2);

    if (showUnsaved) {
        document.getElementById("tool-save").classList.add("unsaved");
    }
}

function loadState(data) {
    if (!("version" in data)) {
        console.log("Loading legacy state");
        loadStateLegacy(data);
        return
    }

    document.querySelectorAll(".note,.line,.arrow,.page").forEach(e => e.remove());
    for (let p = 0; p < data.pages; p++) {
        makePage();
    }
    if (data.title) {
        document.getElementById("sidebar-title").innerText = data.title;
    }
    data.notes.forEach(n => {
        createNote(n.type, n.x, n.y, getRestoredText(n));
    });
    data.lines.forEach(l => {
        createLine(l.x1, l.y1, l.x2, l.y2);
    });
    data.arrows.forEach(l => {
        createArrow(l.x1, l.y1, l.x2, l.y2);
    });
    updateState(false);
}

function loadStateLegacy(data) {
    document.querySelectorAll(".note,.line,.arrow,.page").forEach(e => e.remove());
    for (let p = 0; p < data.pages; p++) {
        makePage();
    }
    if (data.title) {
        document.getElementById("sidebar-title").innerText = data.title;
    }
    data.tapes.forEach(l => {
        createTape(l.x, l.y, l.text);
    });
    data.notes.forEach(n => {
        const el = createPostIt(n.x, n.y);
        el.innerHTML = restoreHTMLNewLines(n.text);
    });
    data.papers.forEach(p => {
        const el = createPaper(p.x, p.y);
        el.innerHTML = restoreHTMLNewLines(p.text);
    });
    data.lines.forEach(l => {
        createLine(l.x1, l.y1, l.x2, l.y2);
    });
    data.arrows.forEach(l => {
        createArrow(l.x1, l.y1, l.x2, l.y2);
    });
    updateState(true);
}

const STORAGE_KEY = "mapper";

function newDiagram() {
    const state = {
        title: "New Diagram",
        pages: 1,
        tapes: [],
        notes: [],
        papers: [],
        lines: [],
        arrows: []
    }
    loadState(state);

}

function saveDiagram() {
    const diagram = {
        id: state.title,
        data: state,
        createdAt: Date.now(),
        updatedAt: Date.now()
    }

    const data = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{"diagrams":[]}');
    
    // check if this diagram already exists
    const index = data.diagrams.findIndex(d => d.id === diagram.id);
    diagram.updatedAt = Date.now();

    if (index >= 0) {
        data.diagrams[index] = diagram;
    } else {
        data.diagrams.push(diagram);
    }

    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));

    document.getElementById("tool-save").classList.remove("unsaved");
}

function loadDiagram(id) {
    console.log("Loading diagram: " + id);
    const data = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{"diagrams":[]}');
    const diagram = data.diagrams.find(d => d.id === id);
    if (!diagram) return null;

    loadState(diagram.data);
    return diagram;
}

function deleteDiagram(id) {
    // Load the saved diagrams
    const saved = localStorage.getItem(STORAGE_KEY);
    if (!saved) return;

    const obj = JSON.parse(saved);

    // Filter out the diagram to delete
    obj.diagrams = obj.diagrams.filter(d => d.id !== id);

    // Save back to localStorage
    localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
}

/* PROTOTYPING */

// Refresh the sidebar list
function refreshDiagramList() {
    const list = document.getElementById("diagram-list");
    list.innerHTML = "";

    getAllDiagrams().forEach((d, index) => {
        const title = d.id;
        const item = document.createElement("div");
        item.classList.add("diagram-item");
        item.addEventListener("click", () => loadDiagram(title));

        const label = document.createElement("span");
        label.textContent = title;

        const up = document.createElement("button");
        up.textContent = "↑";
        up.addEventListener("click", e => {
            e.stopPropagation();
            moveDiagram(index, -1);
        });

        const down = document.createElement("button");
        down.textContent = "↓";
        down.addEventListener("click", e => {
            e.stopPropagation();
            moveDiagram(index, +1);
        });

        const del = document.createElement("button");
        del.classList.add("diagram-delete-button");
        del.textContent = "✕";   // small delete icon
        del.addEventListener("click", e => {
            e.stopPropagation(); // prevent triggering the load
            if (confirm(`Delete diagram "${title}"?`)) {
                deleteDiagram(title);
                refreshDiagramList();
            }
        });

        const controls = document.createElement("div");
        controls.className = "diagram-controls";
        controls.append(up, down, del);

        item.append(label, controls);
        list.appendChild(item);
    });
}

function moveDiagram(index, direction) {
    const data = JSON.parse(localStorage.getItem(STORAGE_KEY));
    const diagrams = data.diagrams;

    const newIndex = index + direction;
    if (newIndex < 0 || newIndex >= diagrams.length) return;

    // swap
    [diagrams[index], diagrams[newIndex]] = [diagrams[newIndex], diagrams[index]];

    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    refreshDiagramList();
}

function getAllDiagrams() {
    const data = JSON.parse(localStorage.getItem(STORAGE_KEY));
    return data.diagrams;
}

// Initialize list on load
refreshDiagramList();


function downloadDiagrams() {
    const data = localStorage.getItem(STORAGE_KEY);
    if (!data) {
        alert("No diagrams saved in localStorage.");
        return;
    }

    const formatted = JSON.stringify(JSON.parse(data), null, 2);

    // Convert to a Blob for download
    const blob = new Blob([formatted], { type: "application/json" });
    const url = URL.createObjectURL(blob);

    const now = new Date();
    const pad = n => n.toString().padStart(2, "0");
    const timestamp = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;

    // Create temporary link to trigger download
    const a = document.createElement("a");
    a.href = url;
    a.download = `mapper_${timestamp}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    // Release the URL
    URL.revokeObjectURL(url);
}


const importFileInput = document.getElementById("import-file");

function importJson() {
    importFileInput.value = ""; // allow re-importing same file
    importFileInput.click();
}

importFileInput.addEventListener("change", () => {
    const file = importFileInput.files[0];
    if (!file) return;

    const reader = new FileReader();

    reader.onload = () => {
        try {
            const imported = JSON.parse(reader.result);

            // Basic validation
            if (!imported || !Array.isArray(imported.diagrams)) {
                throw new Error("Invalid diagram file");
            }

            // Replace localStorage data
            localStorage.setItem("mapper", JSON.stringify(imported));
            location.reload();
        } catch (err) {
            alert("Failed to import file: " + err.message);
        }
    };

    reader.readAsText(file);
});

let mouseX = 0;
let mouseY = 0;

document.addEventListener("mousemove", e => {
    mouseX = e.pageX;
    mouseY = e.pageY;
});

document.addEventListener("keydown", e => {
    // Ignore repeats (holding key down)
    if (e.repeat) return;

    // Ignore when editing a note
    if (editingNote) return;

    const active = document.activeElement;

    // Ignore when typing into editable elements
    if (active &&
        (active.isContentEditable || active.tagName === "INPUT" || active.tagName === "TEXTAREA")) {
        return;
    }

    clearEditingNote();

    const x = mouseX;
    const y = mouseY;

    if (e.key === "1") {
        e.preventDefault();
        const el = createTape(x, y);
        makeEditable(el, true);
        updateState();
    } else if (e.key === "2") {
        e.preventDefault();
        const el = createPostIt(x, y);
        makeEditable(el, true);
        updateState();
    } else if (e.key === "3") {
        e.preventDefault();
        const el = createPaper(x, y);
        makeEditable(el, true);
        updateState();
    }
});

function addImage() {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "image/*";

    input.onchange = () => {
        const file = input.files[0];
        if (!file) return;

        processImageFile(file, {}, dataUrl => {
            createImageNoteFromDataUrl(dataUrl);
        });
    };

    input.click();
}

document.addEventListener("paste", e => {
    const items = e.clipboardData?.items;
    if (!items) return;

    for (const item of items) {
        if (item.type.startsWith("image/")) {
            e.preventDefault();
            const file = item.getAsFile();

            processImageFile(file, {}, dataUrl => {
                const x = mouseX;
                const y = mouseY;
                createImageNoteFromDataUrl(dataUrl, x, y);
            });

            break;
        }
    }
});

function createImageNoteFromDataUrl(dataUrl, x = 500, y = 100) {
    const note = createPaper(x, y);
    note.innerHTML = `<img src="${dataUrl}" style="max-width:100%; height:auto;">`;
    updateState();
}

function processImageFile(file, {
    maxWidth = 300,
    maxHeight = 300,
    mime = "image/jpeg",
    quality = 0.7
} = {}, callback) {
    const img = new Image();
    const reader = new FileReader();

    reader.onload = e => {
        img.src = e.target.result;
    };

    img.onload = () => {
        let { width, height } = img;

        if (width > maxWidth || height > maxHeight) {
            const scale = Math.min(maxWidth / width, maxHeight / height);
            width *= scale;
            height *= scale;
        }

        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;

        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, width, height);

        const dataUrl = canvas.toDataURL(mime, quality);
        callback(dataUrl);
    };

    reader.readAsDataURL(file);
}

loadDiagram("Home"); // Load the home diagram, if available, by default
    </script>
</html>